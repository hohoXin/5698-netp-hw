/*
 * [2019] Signet Lab - Programming for ICT
 * [2020] Northeastern University - Network Programming
 * All Rights Reserved.
 * 
 * Authors Filippo Campagnaro and Michele Polese 
*/

#ifndef STRUCTS_ENUM_TEST
#define STRUCTS_ENUM_TEST

#include <vector>

/**
 * Namespace StructsEnumsTest containing the structs and enums used as examples for this class
 */
namespace StructsEnumsTest
{

/**
 * struct Address with the info that can identity an address in the U.S.
 */
struct Address {
  const char* name;
  int number;
  const char* street;
  const char* town;
  char state[2];
  const char* zip;
};

// consider a list composed of multiple elements, linked to each other
// it is possible to represent it with the struct Element, with pointers
// to the next and the previous Element. Moreover, we want to have a member
// that represents the List in which the Element is hosted.
// We can first forward declare the struct List, and define it later
struct List;

/**
 * struct Element, representing an integer value and with pointers
 * to a linked list and the previous and next elements
 */
struct Element {
  Element* previous;
  Element* next;
  List* member_of;
  int data;
};

/**
 * struct List, with a pointer to the first element of the list
 */
struct List {
  Element* head;
};

/**
 * struct Numbers, with a vector of int
 */
struct Numbers {
  std::vector<int> elem;
  Numbers(int n1, int n2) {
    elem.push_back(n1);
    elem.push_back(n2);
  }
};

/**
 * struct Trivial. This structure does not do anything except wrapping an int.
 * It is simple enough (with a user-provided constructor and a 
 * constructor generated by the compiler) to be considered a POD
 */
struct Trivial {
  int a; 
  Trivial(int aa) : a(aa) { } 
  Trivial() = default; // use the compiler generated 
                       // constructor
}; 

// define an enum class

/** 
 *  Strongly typed enum class representing the status of a traffic light
 */
enum class TrafficLight {green, yellow, red};

// and another class with the same enumerators,
// they do not clash

/** 
 *  Strongly typed enum class representing something that can be green or blue
 */
enum class Other : char {green, blue}; // no name clash!


// the values for this enum are explicitely
// defined, in order to be combined with an overloaded operator

/** 
 *  Strongly typed enum class representing printer status
 */
enum class Printer_flags {
  busy=1,
  out_of_black=2,
  out_of_color=4
}; 

constexpr Printer_flags operator&(Printer_flags a, Printer_flags b) {
    return static_cast<Printer_flags>(static_cast<int>(a)&static_cast<int>(b)); 
}

constexpr Printer_flags operator|(Printer_flags a, Printer_flags b) {
    return static_cast<Printer_flags>(static_cast<int>(a)|static_cast<int>(b)); 
}

// enums are not scoped, and can be implicitly converted to int

/** 
 *  Not-typed enum representing the status of a traffic light
 */
enum TrafficLightEnum {green, yellow, red};

// enum OtherEnum {green, blue}; // this gives a compilation error, enumerators
// in plain enums are not scoped!

// you can scope an enum by declaring it in a class or struct

/**
 * struct EnumScoped holds an enum
 */
struct EnumScoped {
  enum OtherEnum {green, blue}; // no compilation error
};

}

#endif /* STRUCTS_ENUM_TEST */